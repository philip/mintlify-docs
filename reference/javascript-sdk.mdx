---
title: Neon Auth & Data API TypeScript SDKs
subtitle: Reference documentation for building applications with Neon Auth and Data API
description: >-
  Covers the setup and usage of the Neon TypeScript SDK for implementing
  authentication and database operations in applications, including various
  adapter options for different frameworks.
---

The Neon TypeScript SDK (`@neondatabase/neon-js`) provides authentication and database operations for your applications.

Authentication is provided through an adapter-based architecture, letting you work more easily with your existing code or preferred framework. Available adapters:

- **BetterAuthVanillaAdapter** (default): Promise-based authentication methods like `client.auth.signIn.email()`. Used in all examples on this page.
- **BetterAuthReactAdapter**: Similar API but with React hooks like `useSession()`. See the [React quickstart](/auth/quick-start/react).
- **SupabaseAuthAdapter**: Supabase-compatible API for easy migration. See the [migration guide](/auth/migrate/from-supabase).

Database query methods (`client.from()`, `.select()`, etc.) work the same regardless of which adapter you use.

## Setup

### Installation

Install the TypeScript SDK in your project using npm, yarn, pnpm, or bun.

```bash
npm install @neondatabase/neon-js
```

### Initialize the client

**Full client (`createClient`)** — use when you need both authentication and database queries:

- Auth methods like `client.auth.signIn.email()` and `client.auth.signUp.email()`
- Database queries like `client.from('todos').select()` and `client.from('users').insert()`

**Auth-only client (`createAuthClient`)** — use when you only need authentication (no database queries):

- Auth methods like `auth.signIn.email()` and `auth.signUp.email()`
- No database query methods

The auth methods are identical; only the access path differs. `client.auth.signIn.email()` and `auth.signIn.email()` do the same thing.

<CodeGroup>

```typescript Full client
import { createClient } from '@neondatabase/neon-js';

const client = createClient({
  auth: {
    url: import.meta.env.VITE_NEON_AUTH_URL,
  },
  dataApi: {
    url: import.meta.env.VITE_NEON_DATA_API_URL,
  },
});
```

```typescript Auth-only
import { createAuthClient } from '@neondatabase/neon-js/auth';

const auth = createAuthClient(import.meta.env.VITE_NEON_AUTH_URL);
```

```typescript With TypeScript types
import { createClient } from '@neondatabase/neon-js';
import type { Database } from './types/database.types';

const client = createClient<Database>({
  auth: {
    url: import.meta.env.VITE_NEON_AUTH_URL,
  },
  dataApi: {
    url: import.meta.env.VITE_NEON_DATA_API_URL,
  },
});
```

```typescript With a different adapter
import { createClient } from '@neondatabase/neon-js';
import { BetterAuthReactAdapter } from '@neondatabase/neon-js/auth/react/adapters';

const client = createClient({
  auth: {
    adapter: BetterAuthReactAdapter(),
    url: import.meta.env.VITE_NEON_AUTH_URL,
  },
  dataApi: {
    url: import.meta.env.VITE_NEON_DATA_API_URL,
  },
});
```

</CodeGroup>

## Authentication

### auth.signUp.email()

Create a new user account. Returns user and session data on success. User data is stored in your database and sessions are managed automatically.

<ParamField body="email" type="string" required>
  User's email address
</ParamField>

<ParamField body="name" type="string" required>
  User's display name
</ParamField>

<ParamField body="password" type="string" required>
  Account password
</ParamField>

<ParamField body="image" type="string">
  Profile image URL
</ParamField>

<ParamField body="callbackURL" type="string">
  URL to redirect to after sign-up
</ParamField>

```typescript
const result = await client.auth.signUp.email({
  email: 'user@example.com',
  password: 'password123',
  name: 'John Doe'
})

if (result.error) {
  console.error('Sign up error:', result.error.message)
} else {
  console.log('User created:', result.data.user)
}
```

### auth.signIn.email()

Sign in with email and password. Returns user and session on success. Session tokens are cached automatically and authentication state syncs across browser tabs.

<ParamField body="email" type="string" required>
  User's email address
</ParamField>

<ParamField body="password" type="string" required>
  Account password
</ParamField>

<ParamField body="rememberMe" type="boolean">
  Whether to persist the session
</ParamField>

<ParamField body="callbackURL" type="string">
  URL to redirect to after sign-in
</ParamField>

```typescript
const result = await client.auth.signIn.email({
  email: 'user@example.com',
  password: 'password123'
})

if (result.error) {
  console.error('Sign in error:', result.error.message)
} else {
  console.log('Signed in:', result.data.user.email)
}
```

### auth.signIn.social()

Sign in with an OAuth provider like Google, GitHub, etc. Redirects user to the provider's authorization page, then back to your app after authorization.

<ParamField body="provider" type="string" required>
  OAuth provider name (e.g., `"github"`, `"google"`)
</ParamField>

<ParamField body="callbackURL" type="string">
  URL to redirect to after authorization
</ParamField>

<ParamField body="newUserCallbackURL" type="string">
  URL to redirect new users to after first sign-in
</ParamField>

<ParamField body="errorCallbackURL" type="string">
  URL to redirect to on error
</ParamField>

<ParamField body="disableRedirect" type="boolean">
  Disable automatic redirect
</ParamField>

<ParamField body="idToken" type="object">
  ID token for token-based OAuth
</ParamField>

<ParamField body="scopes" type="string[]">
  OAuth scopes to request
</ParamField>

<ParamField body="requestSignUp" type="boolean">
  Whether to create a new account if user doesn't exist
</ParamField>

<ParamField body="loginHint" type="string">
  Pre-fill the login form with this email
</ParamField>

<ParamField body="additionalData" type="object">
  Additional data to pass to the provider
</ParamField>

<CodeGroup>

```typescript Sign in with GitHub
await client.auth.signIn.social({
  provider: 'github',
  callbackURL: 'https://yourapp.com/auth/callback',
});
```

```typescript Sign in with Google
await client.auth.signIn.social({
  provider: 'google',
  callbackURL: 'https://yourapp.com/auth/callback',
});
```

</CodeGroup>

### auth.signOut()

Sign out the current user. Clears local session cache, notifies other browser tabs (cross-tab sync), and removes authentication tokens.

```typescript
const { error } = await client.auth.signOut()

if (error) {
  console.error('Sign out error:', error.message)
}
```

### auth.getSession()

Get the current session. Returns cached session if available (fast), automatically refreshes expired tokens, and returns null if no active session.

```typescript
const { data, error } = await client.auth.getSession()

if (data.session) {
  console.log('User is logged in:', data.session.user.email)
} else {
  console.log('No active session')
}
```

### auth.updateUser()

Update the current user's profile. Password updates require the password reset flow for security.

<ParamField body="name" type="string">
  New display name
</ParamField>

<ParamField body="image" type="string | null">
  New profile image URL, or `null` to remove
</ParamField>

```typescript
const { data, error } = await client.auth.updateUser({
  name: 'New Name'
})
```

### auth.emailOtp.sendVerificationOtp()

Send an OTP (one-time password) code to the user's email. The user must then call `signIn.emailOtp()` with the received code.

<ParamField body="email" type="string" required>
  Email address to send the OTP to
</ParamField>

<ParamField body="type" type='"email-verification" | "sign-in" | "forget-password"' required>
  Purpose of the OTP
</ParamField>

```typescript
const { error } = await client.auth.emailOtp.sendVerificationOtp({
  email: 'user@example.com',
  type: 'sign-in'
})

if (error) {
  console.error('Failed to send OTP:', error.message)
}
```

### auth.signIn.emailOtp()

Sign in using an OTP code received via email. First call `emailOtp.sendVerificationOtp()` to send the code.

<ParamField body="email" type="string" required>
  Email address the OTP was sent to
</ParamField>

<ParamField body="otp" type="string" required>
  The one-time password code
</ParamField>

```typescript
const { data, error } = await client.auth.signIn.emailOtp({
  email: 'user@example.com',
  otp: '123456'
})

if (error) {
  console.error('OTP verification failed:', error.message)
} else {
  console.log('Signed in:', data.user.email)
}
```

### auth.emailOtp.verifyEmail()

Verify a user's email address using an OTP code sent during signup. Typically used after `signUp.email()` when email verification is required.

<ParamField body="email" type="string" required>
  Email address to verify
</ParamField>

<ParamField body="otp" type="string" required>
  The verification code
</ParamField>

```typescript
const { data, error } = await client.auth.emailOtp.verifyEmail({
  email: 'user@example.com',
  otp: '123456'
})

if (error) {
  console.error('Email verification failed:', error.message)
} else {
  console.log('Email verified successfully')
}
```

### auth.emailOtp.checkVerificationOtp()

Check if an OTP code is valid without completing the verification flow. Useful for password reset flows where you need to verify the code before allowing password change.

<ParamField body="email" type="string" required>
  Email address the OTP was sent to
</ParamField>

<ParamField body="type" type='"email-verification" | "sign-in" | "forget-password"' required>
  Purpose of the OTP
</ParamField>

<ParamField body="otp" type="string" required>
  The one-time password code to check
</ParamField>

```typescript
const { data, error } = await client.auth.emailOtp.checkVerificationOtp({
  email: 'user@example.com',
  otp: '123456',
  type: 'forget-password'
})

if (error || !data.success) {
  console.error('Invalid OTP code')
}
```

### auth.sendVerificationEmail()

Send a verification email to the user. Used for email verification after signup or email change.

<ParamField body="email" type="string" required>
  Email address to send verification to
</ParamField>

<ParamField body="callbackURL" type="string">
  URL to redirect to after verification
</ParamField>

```typescript
const { error } = await client.auth.sendVerificationEmail({
  email: 'user@example.com',
  callbackURL: 'https://yourapp.com/verify-email'
})

if (error) {
  console.error('Failed to send verification email:', error.message)
}
```

### auth.verifyEmail()

Verify an email address using a token from a verification email link. Used for email change verification.

<ParamField body="query" type="object" required>
  Object containing `token` and optional `callbackURL`
</ParamField>

```typescript
const { data, error } = await client.auth.verifyEmail({
  query: {
    token: 'verification-token-from-email',
    callbackURL: 'https://yourapp.com/email-verified'
  }
})

if (error) {
  console.error('Email verification failed:', error.message)
}
```

### auth.requestPasswordReset()

Send a password reset email to the user. The email contains a link to reset the password.

<ParamField body="email" type="string" required>
  Email address to send the reset link to
</ParamField>

<ParamField body="redirectTo" type="string">
  URL to redirect to from the reset link
</ParamField>

```typescript
const { error } = await client.auth.requestPasswordReset({
  email: 'user@example.com',
  redirectTo: 'https://yourapp.com/reset-password'
})

if (error) {
  console.error('Failed to send password reset email:', error.message)
}
```

## Data API

### from().select()

Fetch data from a table. Authentication token is included automatically if user is signed in. Returns typed data based on your database schema, and row-level security policies determine what data is returned.

<CodeGroup>

```typescript Select all rows
const { data, error } = await client.from('todos').select('*');
```

```typescript Select specific columns
const { data, error } = await client.from('todos').select('id, title, completed');
```

```typescript Select with filter
const { data, error } = await client.from('todos').select('*').eq('completed', false);
```

```typescript Select with related tables
const { data, error } = await client.from('todos').select('*, owner:users(*)');
```

</CodeGroup>

### from().insert()

Insert data into a table. Authentication token is included automatically. Can insert single or multiple rows.

<CodeGroup>

```typescript Insert a single row
const { data, error } = await client
  .from('todos')
  .insert({ title: 'Buy groceries', completed: false })
  .select();
```

```typescript Insert multiple rows
const { data, error } = await client
  .from('todos')
  .insert([
    { title: 'Task 1', completed: false },
    { title: 'Task 2', completed: false },
  ])
  .select();
```

</CodeGroup>

### from().update()

Update existing rows. Requires a filter to specify which rows to update. Authentication token is included automatically.

```typescript
const { data, error } = await client
  .from('todos')
  .update({ completed: true })
  .eq('id', 1)
  .select()
```

### from().delete()

Delete rows from a table. Requires a filter to specify which rows to delete. Authentication token is included automatically.

<ParamField body="count" type='"exact" | "planned" | "estimated"'>
  Count algorithm to use for the result
</ParamField>

```typescript
const { error } = await client
  .from('todos')
  .delete()
  .eq('id', 1)
```

### .rpc()

Call a stored procedure. Authentication token is included automatically. Pass parameters as an object.

```typescript
const { data, error } = await client.rpc('get_user_stats', {
  user_id: 123,
  start_date: '2024-01-01'
})

if (error) {
  console.error('RPC error:', error.message)
} else {
  console.log('Stats:', data)
}
```

## Query filters

Chain these methods after `.select()`, `.update()`, or `.delete()` to filter results.

<AccordionGroup>

<Accordion title=".eq(column, value)">
Filters rows where the specified column equals the given value. Can be chained with other filters to create complex queries.

```typescript
const { data, error } = await client
  .from('todos')
  .select('*')
  .eq('completed', true)
```
</Accordion>

<Accordion title=".neq(column, value)">
Filters rows where the specified column does not equal the given value.

```typescript
const { data, error } = await client
  .from('todos')
  .select('*')
  .neq('status', 'archived')
```
</Accordion>

<Accordion title=".gt(column, value)">
Filters rows where the specified column is greater than the given value. Works with numeric values, dates, and other comparable types.

```typescript
const { data, error } = await client
  .from('todos')
  .select('*')
  .gt('priority', 5)
```
</Accordion>

<Accordion title=".gte(column, value)">
Filters rows where the specified column is greater than or equal to the given value.

```typescript
const { data, error } = await client
  .from('todos')
  .select('*')
  .gte('priority', 5)
```
</Accordion>

<Accordion title=".lt(column, value)">
Filters rows where the specified column is less than the given value. Works with numeric values, dates, and other comparable types.

```typescript
const { data, error } = await client
  .from('todos')
  .select('*')
  .lt('priority', 10)
```
</Accordion>

<Accordion title=".lte(column, value)">
Filters rows where the specified column is less than or equal to the given value.

```typescript
const { data, error } = await client
  .from('todos')
  .select('*')
  .lte('priority', 10)
```
</Accordion>

<Accordion title=".like(column, pattern)">
Filter rows where column matches a pattern (case-sensitive). Use `%` as wildcard.

```typescript
const { data, error } = await client
  .from('todos')
  .select('*')
  .like('title', '%groceries%')
```
</Accordion>

<Accordion title=".ilike(column, pattern)">
Filter rows where column matches a pattern (case-insensitive). Use `%` as wildcard.

```typescript
const { data, error } = await client
  .from('todos')
  .select('*')
  .ilike('title', '%groceries%')
```
</Accordion>

<Accordion title=".is(column, value)">
Filters rows based on whether a column is null or not null.

<CodeGroup>

```typescript Is null
const { data, error } = await client.from('todos').select('*').is('deleted_at', null);
```

```typescript Is not null
const { data, error } = await client.from('todos').select('*').is('completed_at', 'not.null');
```

</CodeGroup>
</Accordion>

<Accordion title=".in(column, array)">
Filters rows where the column value matches any value in the provided array.

```typescript
const { data, error } = await client
  .from('todos')
  .select('*')
  .in('status', ['pending', 'in-progress'])
```
</Accordion>

<Accordion title=".contains(column, value)">
Filters rows where an array or JSONB column contains the specified value. For arrays, checks if the value exists in the array. For JSONB, checks if the value is contained in the JSON object.

```typescript
const { data, error } = await client
  .from('todos')
  .select('*')
  .contains('tags', ['urgent'])
```
</Accordion>

<Accordion title=".range(column, start, end)">
Filters rows where column value is between two values. Range is inclusive (includes both start and end values).

```typescript
const { data, error } = await client
  .from('todos')
  .select('*')
  .range('priority', 5, 10)
```
</Accordion>

<Accordion title=".order(column, options)">
Sorts query results by the specified column.

<CodeGroup>

```typescript Order ascending
const { data, error } = await client
  .from('todos')
  .select('*')
  .order('created_at', { ascending: true });
```

```typescript Order descending
const { data, error } = await client
  .from('todos')
  .select('*')
  .order('created_at', { ascending: false });
```

</CodeGroup>
</Accordion>

<Accordion title=".limit(count)">
Limits the number of rows returned by the query. Useful for pagination and preventing large result sets.

```typescript
const { data, error } = await client
  .from('todos')
  .select('*')
  .limit(10)
```
</Accordion>

</AccordionGroup>
